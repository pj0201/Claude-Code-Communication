# 🛡️ システム信頼性分析 - エラーが出ない仕様設計

**Date**: 2025-10-19
**Purpose**: 進化するシステムの堅牢性確保
**Status**: 分析進行中

---

## 📋 方針

複雑さが増すシステムは、**小さなバグが全体を崩す可能性がある**。
本ドキュメントは、3つの新機能 × 既存学習機能における
**想定されるエラーケース**と**予防策**をまとめる。

---

## 1️⃣ スクロール履歴システムのエラーケース

### ✅ 実装済み機能
- `.tmux.conf`: history-limit 50,000行
- `bin/capture-claude-logs`: 5秒ごとキャプチャ
- `bin/view-claude-logs`: ログ閲覧ツール
- `start-small-team.sh`: 自動起動

### ❌ 潜在的エラー

#### 1-1: ログディレクトリの権限エラー
```
症状: capture-claude-logs が起動しない、または ログファイルが作成されない
原因: /home/planj/.../logs/ の書き込み権限がない
```

**検証コード**:
```bash
# 権限確認
ls -ld /home/planj/Claude-Code-Communication/logs
# 期待値: drwxr-xr-x (755)
```

**予防策**:
- [ ] `start-small-team.sh` でディレクトリ自動作成時に権限を明示的に設定
- [ ] `chmod 755` を追加

#### 1-2: キャプチャプロセスのメモリリーク
```
症状: 時間経過とともに capture-claude-logs のメモリ使用率が増加
原因: 大きなペイン内容を記録し続けると、バッファが溜まる可能性
```

**予防策**:
- [ ] ログファイルサイズの上限設定（例: 100MB/ファイル）
- [ ] 古いログの自動削除ロジック追加
- [ ] メモリ効率的な記録（差分のみ記録）

#### 1-3: tmux セッションが存在しない時の動作
```
症状: start-small-team.sh を実行していない状態で capture-claude-logs が起動
原因: 検証不足（tmux セッション存在確認がない）
```

**予防策**:
- [ ] capture-claude-logs でセッション存在確認を追加
- [ ] セッションなし時は graceful exit

#### 1-4: ペイン 0.1 が存在しない場合
```
症状: ペイン名指定エラー
原因: tmux session 構成が変わった場合
```

**予防策**:
- [ ] ペイン番号をハードコードせず、設定ファイル化
- [ ] エラーメッセージを明確に（どのペインが必要か表示）

---

## 2️⃣ LINE Bridge 応答ポリシーのエラーケース

### ✅ 実装済み機能
- 受付確認即座送信
- response_line_*.json 検出による応答送信
- 2秒ごとポーリング
- 600秒タイムアウト

### ❌ 潜在的エラー

#### 2-1: レース条件（応答ファイルが2つ作成される）
```
症状: LINE に同じメッセージが2回届く
原因:
- Claude Code が複数のタスクを完了して複数の response_line_*.json を作成
- または Bridge のポーリングが重複検出
```

**予防策**:
- [ ] 応答ファイル検出時に **ファイルロック** 機構を追加
- [ ] response_line_*.json 作成時に UUID を付与
- [ ] Bridge が同じ UUID を2回処理しないようチェック

#### 2-2: Outbox ファイル検出の失敗
```
症状: Claude Code が応答ファイルを作成したのに Bridge が検出しない
原因:
- glob パターンマッチが失敗（ファイル名形式が想定と異なる）
- ファイルシステムの遅延（NFS の場合に起こる可能性）
```

**予防策**:
- [ ] glob パターンをより柔軟に（例: response_line*message_id*.json）
- [ ] ファイル作成後、読み取り前に短い遅延を挿入
- [ ] ファイル存在確認を2回実施

#### 2-3: JSON パースエラー
```
症状: 応答ファイルは存在するが Bridge で認識されない
原因: Claude Code が JSON 形式を間違える、または破損
```

**予防策**:
- [ ] JSON パース時に try-except で明示的にエラーキャッチ
- [ ] エラー時のログに **ファイル内容の一部を出力** する
- [ ] Claude Code 側で JSON スキーマ検証ツール導入

#### 2-4: タイムアウト時の無返信問題
```
症状: Claude Code がタスク完了したのに 600秒待ってから何も返信されない
原因: 応答ファイルが Outbox でなく別の場所に作成された
```

**予防策**:
- [ ] 複数の場所を監視（例: `processed` フォルダも確認）
- [ ] 600秒後に **エラー通知** を LINE に送信
  ```json
  {
    "status": "error",
    "text": "❌ 600秒以内に応答がありません。タスクが停止している可能性があります。"
  }
  ```

#### 2-5: ファイル削除失敗
```
症状: 応答ファイルが削除されず、次回のタスク時に古いファイルが検出される
原因: ファイルがロックされている、または権限エラー
```

**予防策**:
- [ ] 削除失敗時は retry ロジック（3回まで）
- [ ] 削除失敗時はログに警告を記録
- [ ] 手動削除用スクリプト提供

---

## 3️⃣ Skills 統合設計のエラーケース

### ✅ 設計済み機能
- Skill Registry: タスク/ファイルタイプ → スキルマッピング
- Task Classifier: メッセージ分類
- Skill Selector: スキル選択
- Learning-Skill Integration: 学習統合

### ❌ 潜在的エラー

#### 3-1: タスク分類の誤り
```
症状: ユーザーのメッセージが誤ったカテゴリに分類される
結果: 間違ったスキルが選択される → タスク失敗
```

**予防策**:
- [ ] 分類信頼度が閾値以下の場合は **複数カテゴリを試行**
- [ ] Fallback: 信頼度が低い時は複数スキルを並行実行
- [ ] ユーザーに「このタスクは〇〇と判定しました。正しいですか？」と確認

#### 3-2: スキル Registry の不完全性
```
症状: 新しいタスクタイプが来たが Registry に定義がない
結果: スキル選択が失敗 → タスク実行できない
```

**予防策**:
- [ ] 未知のタスクタイプ時は **デフォルトスキルセット** を使用
- [ ] デフォルト: Context7 + Serena （最汎用スキル）
- [ ] 未知タイプを学習データに記録し、後で Registry に追加

#### 3-3: スキル信頼度スコアの初期値問題
```
症状: 新しいエージェント/スキルを追加すると、初期値が不適切で失敗が増える
原因: 信頼度スコア = 0.5 では低すぎる、または高すぎる
```

**予防策**:
- [ ] スキルタイプ別に初期信頼度を分ける
  - Context7: 0.75 (安定的)
  - Serena: 0.70 (中程度)
  - Playwright: 0.65 (環境依存)
- [ ] 初期値を `SKILL_SETS` に明示

#### 3-4: Fallback チェーンの枯渇
```
症状: Primary/Secondary スキルが両方失敗 → Fallback も失敗
結果: ユーザーに「全て失敗しました」という報告
```

**予防策**:
- [ ] Fallback チェーンは **最低3段階** 用意
  - Primary: 最適スキル
  - Secondary: 代替スキル
  - Tertiary: 基本スキル（Context7）
- [ ] 最終 Fallback 失敗時は **ユーザーに質問を返す**
  ```
  「自動処理が失敗しました。以下のいずれかで対応できますか？」
  ```

#### 3-5: 学習データ不足時の動作
```
症状: システム起動初期、学習データが空
結果: スキル推奨が生成できない
```

**予防策**:
- [ ] 学習データ空時は **デフォルトルール** を適用
- [ ] デフォルトルール: `SKILL_SETS` の設定値をそのまま使用
- [ ] 学習データが蓄積するまでは「学習モード」で動作

---

## 4️⃣ 学習機能との融合ポイントのエラーケース

### ❌ 融合時に起こりうるエラー

#### 4-1: スクロール履歴と学習機能の不整合
```
症状: ログには「タスク成功」と記録されているが、学習エンジンは「失敗」と認識
原因: ログ解析ロジックと学習エンジンの成功判定が異なる
```

**予防策**:
- [ ] 成功/失敗の判定基準を **統一ドキュメント** で定義
- [ ] ログから学習データを抽出する際は、明示的な conversion 関数を用意
- [ ] 不確実な場合は「判定保留」として記録

#### 4-2: LINE Bridge ステータスと学習データの乖離
```
症状:
- response_line_*.json には status="success"
- 学習エンジンには「エラー」と記録されている
原因: response_*.json の status と学習記録の同期ミス
```

**予防策**:
- [ ] response_*.json 作成時に **同時に学習データも書込** む
- [ ] またはbridge が response_*.json を読んで学習データを作成
- [ ] どちらかに統一（推奨: Claude Code が両方書く）

#### 4-3: 融合フロー中のデータ破損
```
症状: ログ → 学習データ → スキル推奨 → 実行 のいずれかでデータが破損
原因: 複数のプロセスが同じファイルにアクセス
```

**予防策**:
- [ ] **ファイルロック機構** を全てのプロセスで実装
- [ ] JSON スキーマ検証を各ステップで実施
- [ ] データ変換時は **バックアップを作成**

#### 4-4: 学習機能がシステムを遅くする
```
症状: Skills 統合を追加したら、タスク実行時間が +5秒増加
原因: 学習データ検索が重い（ファイルスキャン × N回）
```

**予防策**:
- [ ] 学習データを **インデックス化** またはメモリキャッシュ
- [ ] 頻出パターンは事前にキャッシュ
- [ ] 検索タイムアウトを設定（1秒以上かかったらスキップ）

---

## 5️⃣ エラーが出ない仕様設計ガイドライン

### 🛡️ 5大原則

#### 原則1: **Fail-Safe より Fail-Graceful**
```
❌ エラーが出ず黙って失敗
✅ エラーが出たら明確に報告 → ユーザーが対応できる
```

#### 原則2: **段階的な信頼度低下**
```
100% 信頼度から始まるのではなく
初期値: 60-70% → 使用実績で上下
```

#### 原則3: **常にFallback用意**
```
Primary が失敗 → Secondary
Secondary が失敗 → Tertiary (基本スキル Context7)
Tertiary が失敗 → ユーザーに質問返す
```

#### 原則4: **データの冗長性**
```
重要なデータ（学習情報、スキル推奨）は複数の場所に記録
- ファイルシステム
- ログ
- バックアップ
```

#### 原則5: **明示的なステータス追跡**
```
タスク: 送信 → 分類 → スキル選択 → 実行 → 結果
各ステップで status を記録し、ユーザーに表示
```

---

## ✅ 実装チェックリスト

### スクロール履歴システム
- [ ] ログディレクトリ権限確認・自動設定
- [ ] キャプチャプロセスのメモリ監視
- [ ] tmux セッション存在確認
- [ ] ペイン番号の設定ファイル化

### LINE Bridge 応答ポリシー
- [ ] レース条件対策（ファイルロック）
- [ ] glob パターンの柔軟化
- [ ] JSON パースエラーハンドリング
- [ ] 600秒タイムアウト時のエラー通知
- [ ] ファイル削除失敗の retry ロジック

### Skills 統合設計
- [ ] タスク分類信頼度の閾値設定
- [ ] 未知タイプのデフォルトスキルセット
- [ ] 信頼度スコアの初期値定義
- [ ] Fallback チェーン（最低3段階）
- [ ] 学習データ空時のデフォルトルール

### 学習機能との融合
- [ ] 成功/失敗判定基準の統一ドキュメント
- [ ] response_*.json 作成時の学習データ同時記録
- [ ] ファイルロック機構の全プロセス実装
- [ ] 学習データ検索のインデックス化
- [ ] 検索タイムアウト（1秒）設定

---

## 📊 リスク評価マトリクス

| リスク | 発生確率 | 影響度 | 対策優先度 |
|--------|---------|--------|----------|
| ログディレクトリ権限エラー | 中 | 高 | ★★★ |
| レース条件（重複メッセージ） | 低 | 極高 | ★★★ |
| タスク分類誤り | 中 | 高 | ★★★ |
| Fallback チェーン枯渇 | 低 | 高 | ★★★ |
| 学習データ不足初期動作 | 高 | 中 | ★★ |
| JSON パースエラー | 低 | 高 | ★★★ |
| パフォーマンス低下 | 中 | 中 | ★★ |

---

## 🎯 結論

**現在の仕様**:
- ✅ スクロール履歴: 比較的安定（権限とメモリ管理が重要）
- ✅ LINE Bridge: 重要なバグは少ないが、レース条件対策が必須
- ⚠️ Skills 統合: 設計は良いが、実装時に多くのエラーハンドリング必要
- ⚠️ 学習融合: 未実装なため、設計時にエラーパターンを組み込む必要

**推奨アクション**:
1. 上記チェックリストを全て実装してから Phase 1 のスキル統合を開始
2. テスト時に意図的にエラーを発生させ、ハンドリングが正しく動作するか確認
3. 学習機能と融合させる前に、各機能を **独立で十分にテスト**

---

**Status**: 分析完了 → 実装前の品質ゲート確認中
**Next**: ユーザーの指示で実装優先順序決定
