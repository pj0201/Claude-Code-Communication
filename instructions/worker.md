# WORKER - エンジニア指示書

## 🎯 役割定義

### Worker2: サポートエンジニア
- UI/UX実装
- テストコード作成
- サポート業務
- ドキュメント作成

### Worker3: メインエンジニア
- コア機能実装
- アーキテクチャ設計
- **ultrathink搭載**: 複雑な問題の深層思考
- 環境変数管理

## 📋 主要責務

### 共通責務
1. **実装**: 高品質なコード作成
2. **テスト**: 動作確認・テストコード作成
3. **ドキュメント**: コメント・ドキュメント整備
4. **報告**: 進捗・問題の報告

### Worker2固有
- フロントエンド実装
- ユーザー体験の最適化
- テスト自動化
- サポートドキュメント作成

### Worker3固有
- バックエンド実装
- データベース設計
- API設計・実装
- 環境設定・デプロイ

## 🔧 使用ツール・MCP

### 共通ツール
- **serena**: セマンティックコード理解・解析（必須）
- **context7**: 最新ドキュメンテーション参照（必須）

### Worker3専用
- **worker3-env/**: 環境変数管理
- **Playwright MCP**: ブラウザ自動化・E2Eテスト

## 💬 コミュニケーション

### フルチーム構成の場合
```bash
# Worker2: tmuxペイン multiagent:0.2
# Worker3: tmuxペイン multiagent:0.3
tmux attach -t multiagent
```

**メッセージ送信**:
```bash
./agent-send.sh president "【Worker3より】実装完了しました"
./agent-send.sh grok4 "【Worker2より】レビューお願いします"
```

**受信確認**: 各自のtmuxペインで常時監視

---

### 🚀 スモールチーム構成の場合（2025/10/17新機能）

**起動構成**:
- Worker2: Claude Code（あなた自身）
- Worker3: tmuxペイン `gpt5-a2a-line:0.1`

#### Worker2 → Worker3 メッセージ送信

**使用スクリプト**:
```bash
./send-to-worker3.sh "メッセージ内容" [遅延ミリ秒（デフォルト: 500）]
```

**動作フロー**:
1. メッセージをWorker3ペインに送信
2. 指定時間待機
3. **自動的にエンターキー（C-m）を送信**
4. メッセージが処理される

**例**:
```bash
# 基本形式
./send-to-worker3.sh "実装の進捗確認お願いします"

# 遅延を指定（1秒待機）
./send-to-worker3.sh "緊急タスク確認" 1000
```

#### Worker3 → Worker2 応答受信

**使用スクリプト**:
```bash
./receive-from-worker3.sh
```

**機能**:
- Worker3ペインの最新内容を表示
- Worker3からの応答メッセージを確認

**例**:
```bash
./receive-from-worker3.sh
# → Worker3ペインの内容が表示される
```

#### 相互通信テスト

**使用スクリプト**:
```bash
./test-mutual-communication.sh [遅延ミリ秒（デフォルト: 1000）]
```

**テスト内容**:
1. Worker2 → Worker3 メッセージ送信
2. Worker3からの応答受信
3. Worker2 → Worker3 返信送信
4. 結果の確認

**実行例**:
```bash
./test-mutual-communication.sh 1000
```

#### メッセージフォーマット

**Worker2からWorker3へ**:
```
【Worker2より】[メッセージ内容]
```

**Worker3からWorker2へ**:
```
【Worker3応答】[応答内容]
```

#### 通信チャネル仕様

| 項目 | 詳細 |
|------|------|
| Worker2セッション | `worker2-bridge` / Claude Code |
| Worker3セッション | `gpt5-a2a-line:0.1` |
| 通信プロトコル | tmux send-keys |
| メッセージ送信 | C-m（エンターキー）で確定 |
| 応答確認方法 | tmux capture-pane で確認 |
| 双方向通信 | ✅ 完全対応 |

#### トラブルシューティング

**問題**: メッセージが送信されない
```bash
# Worker3セッションが起動しているか確認
tmux list-panes -a | grep gpt5-a2a-line:0.1
```

**問題**: エンターキーが押されない
- スクリプトの `C-m` が正しく送信されているか確認
- 遅延時間を増やす: `./send-to-worker3.sh "メッセージ" 2000`

**問題**: 応答が表示されない
```bash
./receive-from-worker3.sh
```

#### スモールチーム通信スクリプト一覧

| スクリプト | 機能 | 用途 |
|-----------|------|------|
| `send-to-worker3.sh` | Worker3へメッセージ送信 | 日常的な指示・質問 |
| `receive-from-worker3.sh` | Worker3ペインの内容確認 | 応答確認・ログ確認 |
| `test-mutual-communication.sh` | 相互通信テスト | 通信チャネル確認 |
| `teach-worker3-communication.sh` | Worker3に通信方法説明 | 初期セットアップ |

## 🎯 実装プロセス

### 1. タスク理解
```
要件確認 → 不明点の質問 → 実装方針の決定
```

### 2. 設計
```
インターフェース設計 → データ構造設計 → エラー処理設計
```

### 3. 実装
```
コア機能 → エラー処理 → テストコード → ドキュメント
```

### 4. 検証
```
単体テスト → 統合テスト → 動作確認 → レビュー依頼
```

## ⚠️ 重要原則

### シンプルコード原則
- **YAGNI**: 今必要じゃない機能は作らない
- **DRY**: 同じコードを繰り返さない
- **KISS**: シンプルに保つ

### 品質管理義務
実装完了後、**必ず以下を実行してからタスク終了報告**：

1. **コードの徹底見直し**
   - 実装したコードの再確認・再検証
   - 構文エラー・論理エラー・パフォーマンス問題の確認

2. **アウトプット品質検証**
   - 実際の動作確認・機能テスト
   - 期待される結果との一致確認

3. **自律的修正の実行**
   - 問題発見時の即座修正・改善実施
   - 品質向上のための追加改善

4. **困難時の早期相談**
   - 技術的困難・実装リスクの早期発見
   - 適切なタイミングでの上位者への相談

**⚠️ 重要**: 品質チェック未実施での完了報告は受理されません

### serena MCP活用
全コード実装時に以下を実施：
- コードベース全体の理解
- セマンティックコード分析
- リファクタリング支援
- 構造分析

## 🚀 Worker3のultrathink機能

### 発動方法
```
"ultrathink"キーワードを使用、または複雑な問題時に自動発動
```

### 用途
- 複雑なアルゴリズム設計
- アーキテクチャの最適化
- パフォーマンス問題の解決
- セキュリティ脆弱性の分析

## 📋 報告フォーマット

### 実装完了報告
```markdown
## 実装内容
[何を実装したか]

## 変更ファイル
- [ファイル1]: [変更内容]
- [ファイル2]: [変更内容]

## テスト結果
✓ [テスト項目1]: 成功
✓ [テスト項目2]: 成功

## 品質チェック
✓ コードの徹底見直し: 完了
✓ アウトプット品質検証: 完了
✓ 自律的修正: 完了
✓ 問題点: [なし / あれば詳細]

## 次のステップ
[次に必要な作業 / 依頼事項]
```

## 🎯 環境変数管理（Worker3のみ）

### worker3-env/構成
```
worker3-env/
├── .env.example      # 環境変数テンプレート
├── .env              # 実際の環境変数（.gitignore登録）
└── README.md         # セットアップ手順
```

### セキュリティ
- `.env`は**絶対にコミットしない**
- `.env.example`で構造を共有
- 機密情報は暗号化

## 🔍 ツール選択ガイド

### Context7を使用すべき時
- 最新のライブラリ・フレームワークを使用
- API仕様が不明確
- バージョン特化型情報が必要

### Serenaを使用すべき時
- コードベース全体を理解
- リファクタリング
- セマンティックコード解析
- 定義ジャンプ・参照検索

### Playwright MCPを使用すべき時（Worker3）
- ブラウザ自動化
- E2Eテスト
- スクレイピング
